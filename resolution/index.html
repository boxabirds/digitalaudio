<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rusty Samples - Audio Resolution Demo</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      padding: 16px;
      background: #0a0a0a;
      color: #e0e0e0;
    }
    h1 {
      margin-bottom: 8px;
      font-size: 24px;
    }
    h2 {
      margin-top: 24px;
      margin-bottom: 12px;
      font-size: 18px;
    }
    button {
      padding: 8px 16px;
      margin-right: 8px;
      background: #1a1a1a;
      color: #e0e0e0;
      border: 1px solid #333;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover:not(:disabled) {
      background: #2a2a2a;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    input[type="range"] {
      flex: 1;
      min-width: 200px;
    }
    input[type="checkbox"] {
      margin: 0;
    }
    label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .error-box {
      margin-top: 8px;
      padding: 8px;
      background: #fee;
      color: #900;
      border: 1px solid #f99;
      border-radius: 4px;
    }
    .controls {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-top: 12px;
    }
    .param-grid {
      margin-top: 12px;
      display: grid;
      grid-template-columns: 160px 1fr auto;
      gap: 8px;
      align-items: center;
    }
    .canvas-container {
      width: 100%;
      height: 160px;
      border: 1px solid #333;
      border-radius: 6px;
      overflow: hidden;
      background: #111;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useMemo, useRef } = React;

    // Simplified AudioGraph without SharedArrayBuffer
    class AudioGraph {
      constructor() {
        this.ctx = null;
        this.audioBuffer = null;
        this.sourceNode = null;
        this.scriptNode = null;
        this.lastNormalizeGain = null;
        this.bitDepth = 12;
        this.holdSamples = 1;
        this.monitorData = new Float32Array(2048);
        this.isPlaying = false;
      }

      async init() {
        if (this.ctx) return;
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      }

      async recordOneSecond(normalizePeak = true, targetPeak = 0.95) {
        if (!this.ctx) await this.init();

        const sr = this.ctx.sampleRate;
        const duration = 1.0;
        const frames = Math.floor(sr * duration);

        const stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false,
          },
        });

        const source = this.ctx.createMediaStreamSource(stream);
        const recorder = this.ctx.createScriptProcessor(4096, 1, 1);

        const samples = [];
        let recordedFrames = 0;

        return new Promise((resolve, reject) => {
          recorder.onaudioprocess = (e) => {
            const inputData = e.inputBuffer.getChannelData(0);
            const remaining = frames - recordedFrames;
            const toRecord = Math.min(inputData.length, remaining);

            for (let i = 0; i < toRecord; i++) {
              samples.push(inputData[i]);
            }

            recordedFrames += toRecord;

            if (recordedFrames >= frames) {
              source.disconnect();
              recorder.disconnect();
              stream.getTracks().forEach(t => t.stop());

              // Create AudioBuffer
              this.audioBuffer = this.ctx.createBuffer(1, frames, sr);
              const channelData = this.audioBuffer.getChannelData(0);

              for (let i = 0; i < frames; i++) {
                channelData[i] = samples[i] || 0;
              }

              if (normalizePeak) {
                this.lastNormalizeGain = this.normalizeBuffer(targetPeak);
              } else {
                this.lastNormalizeGain = null;
              }

              resolve({ sampleRate: sr, frames });
            }
          };

          source.connect(recorder);
          recorder.connect(this.ctx.destination);
        });
      }

      async startLoopPlayback() {
        if (!this.ctx || !this.audioBuffer) throw new Error('No audio buffer');

        this.isPlaying = true;
        this.playLoop();
      }

      playLoop() {
        if (!this.isPlaying || !this.audioBuffer) return;

        const sr = this.ctx.sampleRate;
        const sourceBuffer = this.audioBuffer;

        // Create a new buffer with effects applied
        const processedBuffer = this.ctx.createBuffer(1, sourceBuffer.length, sr);
        const sourceData = sourceBuffer.getChannelData(0);
        const processedData = processedBuffer.getChannelData(0);

        // Apply sample-and-hold and bit depth reduction
        const BITS_MAX = 24;
        const bits = Math.max(1, Math.min(BITS_MAX, this.bitDepth));
        const step = 2 / (Math.pow(2, bits) - 1);

        let held = 0;
        let phase = 0;

        for (let i = 0; i < sourceData.length; i++) {
          // Sample and hold
          if (phase <= 0) {
            held = sourceData[i];
            phase = this.holdSamples;
          }
          phase -= 1;

          // Bit depth quantization
          const q = Math.round((held + 1) / step) * step - 1;
          const crushed = Math.max(-1, Math.min(1, q));

          processedData[i] = crushed;
        }

        // Update monitor data (last 2048 samples)
        const monitorStart = Math.max(0, processedData.length - 2048);
        for (let i = 0; i < 2048; i++) {
          const idx = monitorStart + i;
          this.monitorData[i] = idx < processedData.length ? processedData[idx] : 0;
        }

        // Play the buffer
        this.sourceNode = this.ctx.createBufferSource();
        this.sourceNode.buffer = processedBuffer;
        this.sourceNode.loop = false;
        this.sourceNode.connect(this.ctx.destination);

        const duration = processedBuffer.duration;
        this.sourceNode.start(0);

        // Schedule next loop
        setTimeout(() => {
          if (this.isPlaying) {
            this.playLoop();
          }
        }, duration * 1000);
      }

      stopLoopPlayback() {
        this.isPlaying = false;
        if (this.sourceNode) {
          try {
            this.sourceNode.stop();
          } catch (e) {
            // Ignore if already stopped
          }
          this.sourceNode = null;
        }
      }

      setHoldSamples(value) {
        this.holdSamples = Math.max(1, value);
      }

      setBitDepth(value) {
        this.bitDepth = Math.max(1, Math.min(24, value));
      }

      getLoopSnapshot(decimate = 32) {
        if (!this.audioBuffer) return undefined;
        const data = this.audioBuffer.getChannelData(0);
        const len = Math.max(1, Math.floor(data.length / decimate));
        const out = new Float32Array(len);
        let j = 0;
        for (let i = 0; i < len; i++) {
          out[i] = data[j];
          j += decimate;
        }
        return out;
      }

      getSampleRate() {
        return this.ctx?.sampleRate;
      }

      getMonitorTile() {
        return this.monitorData;
      }

      normalizeBuffer(targetPeak = 0.95) {
        if (!this.audioBuffer) return 1.0;
        const data = this.audioBuffer.getChannelData(0);
        let peak = 0;
        for (let i = 0; i < data.length; i++) {
          const v = Math.abs(data[i]);
          if (v > peak) peak = v;
        }
        if (peak <= 0) return 1.0;
        const gain = Math.max(0, targetPeak / peak);
        if (Math.abs(gain - 1) < 1e-6) return 1.0;
        for (let i = 0; i < data.length; i++) {
          data[i] = Math.max(-1, Math.min(1, data[i] * gain));
        }
        return gain;
      }

      getLastNormalizeGain() {
        return this.lastNormalizeGain;
      }
    }

    // Canvas-based visualization components
    function Waveform({ data, sampleRate = 48000, durationSec = 1.0 }) {
      const canvasRef = useRef(null);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !data) return;

        const ctx = canvas.getContext('2d');
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;

        canvas.width = Math.floor(rect.width * dpr);
        canvas.height = Math.floor(rect.height * dpr);

        const width = canvas.width / dpr;
        const height = canvas.height / dpr;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.scale(dpr, dpr);

        // Background
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, width, height);

        // Grid
        ctx.strokeStyle = '#2a2a2a';
        ctx.fillStyle = '#aaa';
        ctx.lineWidth = 1;
        ctx.font = '12px system-ui';

        const yFor = (v) => (height / 2) - v * (height * 0.45);

        // Y axis
        [-1, 0, 1].forEach((v) => {
          const y = yFor(v);
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
          ctx.fillText(v.toString(), 6, Math.max(12, y - 2));
        });

        // X axis
        const dur = Math.max(0.001, durationSec);
        for (let t = 0; t <= dur + 1e-6; t += 0.1) {
          const x = (t / dur) * (width - 1);
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
          if (Math.abs((t * 10) % 2) < 1e-6) {
            ctx.fillText(t.toFixed(1) + 's', Math.max(0, x + 4), height - 6);
          }
        }

        // Waveform
        ctx.strokeStyle = '#4fc3f7';
        ctx.lineWidth = 2;
        ctx.beginPath();
        const step = data.length / width;
        for (let x = 0; x < width; x++) {
          const i = Math.floor(x * step);
          const y = yFor(data[Math.min(i, data.length - 1)]);
          if (x === 0) ctx.moveTo(0, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.restore();
      }, [data, sampleRate, durationSec]);

      return (
        <div className="canvas-container">
          <canvas ref={canvasRef} />
        </div>
      );
    }

    function Spectrum({ data, sampleRate = 48000 }) {
      const canvasRef = useRef(null);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !data) return;

        const ctx = canvas.getContext('2d');
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;

        canvas.width = Math.floor(rect.width * dpr);
        canvas.height = Math.floor(rect.height * dpr);

        const width = canvas.width / dpr;
        const height = canvas.height / dpr;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.scale(dpr, dpr);

        // Background
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, width, height);

        // Grid
        ctx.strokeStyle = '#2a2a2a';
        ctx.fillStyle = '#aaa';
        ctx.lineWidth = 1;
        ctx.font = '12px system-ui';

        const dbMin = -120, dbMax = 0;

        // Y axis (dB)
        for (let db = dbMax; db >= dbMin; db -= 20) {
          const t = (db - dbMin) / (dbMax - dbMin);
          const y = (1 - t) * (height - 2) + 1;
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
          ctx.fillText(db.toString(), 6, Math.max(12, y - 2));
        }

        // X axis (frequency)
        const nyq = sampleRate / 2;
        const step = nyq <= 8000 ? 1000 : 2000;
        for (let f = 0; f <= nyq + 1; f += step) {
          const x = (f / nyq) * (width - 2) + 1;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
          ctx.fillText(Math.round(f/1000) + 'k', Math.max(0, x + 4), height - 6);
        }

        ctx.fillText('dBFS', 6, 12);
        ctx.fillText('0..' + Math.round(nyq/1000) + 'kHz', width - 80, height - 6);

        // Simple FFT (Cooley-Tukey)
        const fft = (real, imag) => {
          const n = real.length;
          if (n <= 1) return;
          const halfN = n / 2;
          const evenReal = new Float32Array(halfN);
          const evenImag = new Float32Array(halfN);
          const oddReal = new Float32Array(halfN);
          const oddImag = new Float32Array(halfN);
          for (let i = 0; i < halfN; i++) {
            evenReal[i] = real[2 * i];
            evenImag[i] = imag[2 * i];
            oddReal[i] = real[2 * i + 1];
            oddImag[i] = imag[2 * i + 1];
          }
          fft(evenReal, evenImag);
          fft(oddReal, oddImag);
          for (let k = 0; k < halfN; k++) {
            const theta = -2 * Math.PI * k / n;
            const cos = Math.cos(theta);
            const sin = Math.sin(theta);
            const tReal = cos * oddReal[k] - sin * oddImag[k];
            const tImag = cos * oddImag[k] + sin * oddReal[k];
            real[k] = evenReal[k] + tReal;
            imag[k] = evenImag[k] + tImag;
            real[k + halfN] = evenReal[k] - tReal;
            imag[k + halfN] = evenImag[k] - tImag;
          }
        };

        // Zero-pad to power of 2
        let fftSize = 1;
        while (fftSize < data.length) fftSize *= 2;
        fftSize = Math.min(fftSize, 8192);

        const real = new Float32Array(fftSize);
        const imag = new Float32Array(fftSize);

        for (let i = 0; i < Math.min(data.length, fftSize); i++) {
          // Hann window
          const w = 0.5 * (1 - Math.cos(2 * Math.PI * i / (fftSize - 1)));
          real[i] = data[i] * w;
        }

        fft(real, imag);

        const magnitude = new Float32Array(fftSize / 2);
        for (let i = 0; i < fftSize / 2; i++) {
          const mag = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]) / fftSize;
          const db = mag > 1e-10 ? 20 * Math.log10(mag) : -120;
          magnitude[i] = db;
        }

        // Draw spectrum
        ctx.strokeStyle = '#a5d6a7';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let x = 0; x < width; x++) {
          const i = Math.floor((x / width) * magnitude.length);
          const val = magnitude[i];
          const t = Math.max(0, Math.min(1, (val + 120) / 120));
          const y = (1 - t) * (height - 2) + 1;
          if (x === 0) ctx.moveTo(0, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();

        ctx.restore();
      }, [data, sampleRate]);

      return (
        <div className="canvas-container">
          <canvas ref={canvasRef} />
        </div>
      );
    }

    // Main App
    function App() {
      const graph = useMemo(() => new AudioGraph(), []);
      const [status, setStatus] = useState('idle');
      const [bitDepth, setBitDepth] = useState(12);
      const defaultSr = 48000;
      const [effRate, setEffRate] = useState(defaultSr);
      const [error, setError] = useState(null);
      const [normalize, setNormalize] = useState(true);
      const [appliedGain, setAppliedGain] = useState(null);
      const [specData, setSpecData] = useState(undefined);

      async function onRecord() {
        setStatus('recording');
        setError(null);
        try {
          await graph.recordOneSecond(normalize, 0.95);
          setAppliedGain(graph.getLastNormalizeGain());
          setStatus('ready');
        } catch (e) {
          console.error(e);
          setStatus('error');
          setError(e?.message || String(e));
        }
      }

      async function onPlay() {
        try {
          graph.setBitDepth(bitDepth);
          const sr = graph.getSampleRate() ?? defaultSr;
          const hold = Math.max(1, sr / Math.max(500, effRate));
          graph.setHoldSamples(hold);
          await graph.startLoopPlayback();
          setStatus('playing');
        } catch (e) {
          console.error(e);
          setStatus('error');
          setError(e?.message || String(e));
        }
      }

      function onStop() {
        graph.stopLoopPlayback();
        setStatus('ready');
      }

      useEffect(() => {
        let interval;
        if (status === 'playing') {
          interval = setInterval(() => {
            const tile = graph.getMonitorTile();
            if (tile) setSpecData(new Float32Array(tile));
          }, 33); // ~30 FPS
        }
        return () => {
          if (interval) clearInterval(interval);
        };
      }, [status]);

      // Update effects in real-time
      useEffect(() => {
        if (status === 'playing') {
          graph.setBitDepth(bitDepth);
          const sr = graph.getSampleRate() ?? defaultSr;
          const hold = Math.max(1, sr / Math.max(500, effRate));
          graph.setHoldSamples(hold);
        }
      }, [bitDepth, effRate, status]);

      return (
        <div>
          <h1>Rusty Samples</h1>
          <p>Phase 1 — Audio core (record → loop, downsample + bit depth).</p>

          <div style={{ display: 'flex', gap: 8, alignItems: 'center', marginTop: 12 }}>
            <button onClick={onRecord} disabled={status === 'recording'}>
              Record 1s
            </button>
            <button onClick={onPlay} disabled={status !== 'ready'}>
              Play Loop
            </button>
            <button onClick={onStop} disabled={status !== 'playing'}>
              Stop
            </button>
            <span>Status: {status}</span>
          </div>

          <div style={{ marginTop: 8, display: 'flex', gap: 12, alignItems: 'center' }}>
            <label>
              <input type="checkbox" checked={normalize} onChange={(e) => setNormalize(e.target.checked)} />
              Normalize (peak to 0.95)
            </label>
            {appliedGain && Math.abs(appliedGain - 1) > 1e-3 && (
              <span style={{ color: '#666' }}>Applied gain: {appliedGain.toFixed(2)}×</span>
            )}
          </div>

          {error && (
            <div className="error-box">{error}</div>
          )}

          <div className="param-grid">
            <label htmlFor="bitDepth">Bit Depth (post-quantization)</label>
            <input
              id="bitDepth"
              type="range"
              min={1}
              max={24}
              value={bitDepth}
              onChange={(e) => setBitDepth(Number(e.target.value))}
            />
            <span>{bitDepth} bits</span>

            <label htmlFor="effRate">Sample Rate</label>
            <input
              id="effRate"
              type="range"
              min={500}
              max={graph.getSampleRate() ?? defaultSr}
              step={100}
              value={effRate}
              onChange={(e) => setEffRate(Number(e.target.value))}
            />
            <span>{(effRate / 1000).toFixed(1)} kHz</span>
          </div>

          <p style={{ marginTop: 12, color: '#666' }}>
            Tip: Lower bit depth and reduce the sample rate to hear classic bitcrush/decimation artifacts.
          </p>

          <h2>Waveform</h2>
          <Waveform
            data={(status === 'ready' || status === 'playing') ? graph.getLoopSnapshot(48) : undefined}
            sampleRate={graph.getSampleRate() ?? defaultSr}
            durationSec={1.0}
          />

          <h2>Spectrum</h2>
          <Spectrum
            data={specData}
            sampleRate={graph.getSampleRate() ?? defaultSr}
          />
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
